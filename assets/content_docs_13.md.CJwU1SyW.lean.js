import{l as a,c as i,a5 as e,a as n}from"./chunks/framework.DJyBczLA.js";const c=JSON.parse('{"title":"vue-router 中的两种路由模式的区别","description":"","frontmatter":{"title":"vue-router 中的两种路由模式的区别","date":"2022-06-14T00:00:00.000Z","permalink":"/content"},"headers":[],"relativePath":"content/docs/13.md","filePath":"content/docs/13.md","lastUpdated":1733646466000}'),t={name:"content/docs/13.md"};function h(l,s,p,r,o,d){return n(),i("div",null,s[0]||(s[0]=[e(`<h1 id="vue-router-中的两种路由模式的区别" tabindex="-1">vue-router 中的两种路由模式的区别 <a class="header-anchor" href="#vue-router-中的两种路由模式的区别" aria-label="Permalink to &quot;vue-router 中的两种路由模式的区别&quot;">​</a></h1><p>在 vue-router 中我们会去配置路由模式：</p><ul><li>hash(哈希)</li><li>history(历史)</li></ul><p>那么这两种模式有什么区别和优缺点呢，我们一起来探讨一下。</p><h2 id="hash-模式" tabindex="-1">hash 模式 <a class="header-anchor" href="#hash-模式" aria-label="Permalink to &quot;hash 模式&quot;">​</a></h2><h3 id="简述" tabindex="-1">简述 <a class="header-anchor" href="#简述" aria-label="Permalink to &quot;简述&quot;">​</a></h3><p>监听路由的变化：<code>onhashchange</code>事件,只有#后面的地址发生变化，可以在 window 对象上监听这个事件:</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">onhashchange</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(event.oldURL, event.newURL)</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> hash </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> loaction.hash </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//通过location对象来获取hash地址</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(hash) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// &quot;#/notebooks/260827/list&quot;  从#号开始</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>因为 hash 发生变化的 url 都会被浏览器记录下来，从而你会发现浏览器的前进后退都可以用。这样一来，尽管浏览器没有请求服务器，但是页面状态和 url 一一关联起来。</p><h3 id="优点" tabindex="-1">优点 <a class="header-anchor" href="#优点" aria-label="Permalink to &quot;优点&quot;">​</a></h3><ul><li>后面 <code>hash</code> 值的变化，并<strong>不会导致浏览器向服务器发出请求</strong>，浏览器不发出请求，也就不会刷新页面。</li><li>不需要配置即可使用</li></ul><h3 id="缺点" tabindex="-1">缺点 <a class="header-anchor" href="#缺点" aria-label="Permalink to &quot;缺点&quot;">​</a></h3><ul><li>在地址栏中会有一个#号，影响美观。</li></ul><h2 id="history-模式" tabindex="-1">history 模式 <a class="header-anchor" href="#history-模式" aria-label="Permalink to &quot;history 模式&quot;">​</a></h2><h3 id="简述-1" tabindex="-1">简述 <a class="header-anchor" href="#简述-1" aria-label="Permalink to &quot;简述&quot;">​</a></h3><p>随着<code>history api</code>的到来，前端路由开始进化了,前面的<code>hashchange</code>，你只能改变#后面的 url 片段，而<code>history api</code>则给了前端完全的自由。<code>history api</code>可以分为两大部分，切换和修改。</p><h4 id="切换历史状态" tabindex="-1">切换历史状态 <a class="header-anchor" href="#切换历史状态" aria-label="Permalink to &quot;切换历史状态&quot;">​</a></h4><p>包括<code>back</code>,<code>forward</code>,<code>go</code>三个方法，对应浏览器的前进，后退，跳转操作。</p><p>在谷歌浏览器前进后退上长按鼠标，会出来所有当前窗口的历史记录，从而可以跳转(也许叫跳更合适)。</p><div class="language-go vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">history.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">go</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">-</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//后退两次</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">history.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">go</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//前进两次</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">history.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">back</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//后退</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">hsitory.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">forward</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//前进</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h4 id="修改历史状态" tabindex="-1">修改历史状态 <a class="header-anchor" href="#修改历史状态" aria-label="Permalink to &quot;修改历史状态&quot;">​</a></h4><p>因为 HTML5 标准发布，多了两个 API，<code>pushState()</code> 和 <code>replaceState()。</code>通过这两个 API</p><p>（1）可以改变 url 地址且不会发送请求</p><p>（2）不仅可以读取历史记录栈，还可以对<strong>浏览器历史记录栈进行修改</strong></p><p>这两个方法接收三个参数:<code>stateObj</code>,<code>title</code>,<code>url</code>：</p><div class="language-js vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">window.history.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">pushState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(stateObject, title, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">URL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">window.history.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">replaceState</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(stateObject, title, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">URL</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>除此之外，还有<code>popState()</code>.当浏览器跳转到新的状态时，将触发<code>popState</code>事件</p><h3 id="优点-1" tabindex="-1">优点 <a class="header-anchor" href="#优点-1" aria-label="Permalink to &quot;优点&quot;">​</a></h3><ul><li>地址栏中的 url 比 hash 模式的要优雅</li></ul><h3 id="缺点-1" tabindex="-1">缺点 <a class="header-anchor" href="#缺点-1" aria-label="Permalink to &quot;缺点&quot;">​</a></h3><ul><li>需要与后端进行相应的配置才能使用</li></ul><h2 id="区别" tabindex="-1">区别 <a class="header-anchor" href="#区别" aria-label="Permalink to &quot;区别&quot;">​</a></h2><ul><li><p><code>hash</code>模式下，你只能改变#后面的 url 片段。而<code>pushState</code>设置的新 URL 可以是与当前 URL 同源的任意 URL</p></li><li><p><code>history</code>模式则会将 URL 修改得就和正常请求后端的 URL 一样,如后端没有配置对应<code>/user/id</code>的路由处理，则会返回<strong>404</strong>错误</p><p>当用户<strong>刷新</strong>页面之类的操作时，<strong>浏览器会给服务器发送请求</strong>，所以这个实现需要服务器的支持，需要把所有路由都重定向到根页面。如果服务器中没有相应的响应或者资源，会分分钟刷出一个<strong>404</strong>来。</p></li></ul><p>希望本文所述对大家有所帮助。</p>`,34)]))}const E=a(t,[["render",h]]);export{c as __pageData,E as default};
