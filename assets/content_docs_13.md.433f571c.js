import{_ as s,o as a,c as n,Q as o}from"./chunks/framework.c6ce8c78.js";const D=JSON.parse('{"title":"vue-router 中的两种路由模式的区别","description":"","frontmatter":{},"headers":[],"relativePath":"content/docs/13.md","lastUpdated":1690781162000}'),l={name:"content/docs/13.md"},e=o(`<h1 id="vue-router-中的两种路由模式的区别" tabindex="-1">vue-router 中的两种路由模式的区别 <a class="header-anchor" href="#vue-router-中的两种路由模式的区别" aria-label="Permalink to &quot;vue-router 中的两种路由模式的区别&quot;">​</a></h1><p>在 vue-router 中我们会去配置路由模式：</p><ul><li>hash(哈希)</li><li>history(历史)</li></ul><p>那么这两种模式有什么区别和优缺点呢，我们一起来探讨一下。</p><h2 id="hash-模式" tabindex="-1">hash 模式 <a class="header-anchor" href="#hash-模式" aria-label="Permalink to &quot;hash 模式&quot;">​</a></h2><h3 id="简述" tabindex="-1">简述 <a class="header-anchor" href="#简述" aria-label="Permalink to &quot;简述&quot;">​</a></h3><p>监听路由的变化：<code>onhashchange</code>事件,只有#后面的地址发生变化，可以在 window 对象上监听这个事件:</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">window</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">onhashchange</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">=</span><span style="color:#A6ACCD;"> </span><span style="color:#C792EA;">function</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">(</span><span style="color:#A6ACCD;font-style:italic;">event</span><span style="color:#89DDFF;">)</span><span style="color:#A6ACCD;"> </span><span style="color:#89DDFF;">{</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">event</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">oldURL</span><span style="color:#89DDFF;">,</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">event</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">newURL</span><span style="color:#F07178;">)</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#C792EA;">let</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">hash</span><span style="color:#F07178;"> </span><span style="color:#89DDFF;">=</span><span style="color:#F07178;"> </span><span style="color:#A6ACCD;">loaction</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">hash</span><span style="color:#F07178;"> </span><span style="color:#676E95;font-style:italic;">//通过location对象来获取hash地址</span></span>
<span class="line"><span style="color:#F07178;">  </span><span style="color:#A6ACCD;">console</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">log</span><span style="color:#F07178;">(</span><span style="color:#A6ACCD;">hash</span><span style="color:#F07178;">) </span><span style="color:#676E95;font-style:italic;">// &quot;#/notebooks/260827/list&quot;  从#号开始</span></span>
<span class="line"><span style="color:#89DDFF;">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>因为 hash 发生变化的 url 都会被浏览器记录下来，从而你会发现浏览器的前进后退都可以用。这样一来，尽管浏览器没有请求服务器，但是页面状态和 url 一一关联起来。</p><h3 id="优点" tabindex="-1">优点 <a class="header-anchor" href="#优点" aria-label="Permalink to &quot;优点&quot;">​</a></h3><ul><li>后面 <code>hash</code> 值的变化，并<strong>不会导致浏览器向服务器发出请求</strong>，浏览器不发出请求，也就不会刷新页面。</li><li>不需要配置即可使用</li></ul><h3 id="缺点" tabindex="-1">缺点 <a class="header-anchor" href="#缺点" aria-label="Permalink to &quot;缺点&quot;">​</a></h3><ul><li>在地址栏中会有一个#号，影响美观。</li></ul><h2 id="history-模式" tabindex="-1">history 模式 <a class="header-anchor" href="#history-模式" aria-label="Permalink to &quot;history 模式&quot;">​</a></h2><h3 id="简述-1" tabindex="-1">简述 <a class="header-anchor" href="#简述-1" aria-label="Permalink to &quot;简述&quot;">​</a></h3><p>随着<code>history api</code>的到来，前端路由开始进化了,前面的<code>hashchange</code>，你只能改变#后面的 url 片段，而<code>history api</code>则给了前端完全的自由。<code>history api</code>可以分为两大部分，切换和修改。</p><h4 id="切换历史状态" tabindex="-1">切换历史状态 <a class="header-anchor" href="#切换历史状态" aria-label="Permalink to &quot;切换历史状态&quot;">​</a></h4><p>包括<code>back</code>,<code>forward</code>,<code>go</code>三个方法，对应浏览器的前进，后退，跳转操作。</p><p>在谷歌浏览器前进后退上长按鼠标，会出来所有当前窗口的历史记录，从而可以跳转(也许叫跳更合适)。</p><div class="language-go line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">go</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">history</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">go</span><span style="color:#89DDFF;">(-</span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">);</span><span style="color:#676E95;font-style:italic;">//后退两次</span></span>
<span class="line"><span style="color:#A6ACCD;">history</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">go</span><span style="color:#89DDFF;">(</span><span style="color:#F78C6C;">2</span><span style="color:#89DDFF;">);</span><span style="color:#676E95;font-style:italic;">//前进两次</span></span>
<span class="line"><span style="color:#A6ACCD;">history</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">back</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">//后退</span></span>
<span class="line"><span style="color:#A6ACCD;">hsitory</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">forward</span><span style="color:#89DDFF;">();</span><span style="color:#A6ACCD;"> </span><span style="color:#676E95;font-style:italic;">//前进</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h4 id="修改历史状态" tabindex="-1">修改历史状态 <a class="header-anchor" href="#修改历史状态" aria-label="Permalink to &quot;修改历史状态&quot;">​</a></h4><p>因为 HTML5 标准发布，多了两个 API，<code>pushState()</code> 和 <code>replaceState()。</code>通过这两个 API</p><p>（1）可以改变 url 地址且不会发送请求</p><p>（2）不仅可以读取历史记录栈，还可以对<strong>浏览器历史记录栈进行修改</strong></p><p>这两个方法接收三个参数:<code>stateObj</code>,<code>title</code>,<code>url</code>：</p><div class="language-js line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki material-theme-palenight"><code><span class="line"><span style="color:#A6ACCD;">window</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">history</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">pushState</span><span style="color:#A6ACCD;">(stateObject</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> title</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> URL)</span></span>
<span class="line"><span style="color:#A6ACCD;">window</span><span style="color:#89DDFF;">.</span><span style="color:#A6ACCD;">history</span><span style="color:#89DDFF;">.</span><span style="color:#82AAFF;">replaceState</span><span style="color:#A6ACCD;">(stateObject</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> title</span><span style="color:#89DDFF;">,</span><span style="color:#A6ACCD;"> URL)</span></span>
<span class="line"></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>除此之外，还有<code>popState()</code>.当浏览器跳转到新的状态时，将触发<code>popState</code>事件</p><h3 id="优点-1" tabindex="-1">优点 <a class="header-anchor" href="#优点-1" aria-label="Permalink to &quot;优点&quot;">​</a></h3><ul><li>地址栏中的 url 比 hash 模式的要优雅</li></ul><h3 id="缺点-1" tabindex="-1">缺点 <a class="header-anchor" href="#缺点-1" aria-label="Permalink to &quot;缺点&quot;">​</a></h3><ul><li>需要与后端进行相应的配置才能使用</li></ul><h2 id="区别" tabindex="-1">区别 <a class="header-anchor" href="#区别" aria-label="Permalink to &quot;区别&quot;">​</a></h2><ul><li><p><code>hash</code>模式下，你只能改变#后面的 url 片段。而<code>pushState</code>设置的新 URL 可以是与当前 URL 同源的任意 URL</p></li><li><p><code>history</code>模式则会将 URL 修改得就和正常请求后端的 URL 一样,如后端没有配置对应<code>/user/id</code>的路由处理，则会返回<strong>404</strong>错误</p><p>当用户<strong>刷新</strong>页面之类的操作时，<strong>浏览器会给服务器发送请求</strong>，所以这个实现需要服务器的支持，需要把所有路由都重定向到根页面。如果服务器中没有相应的响应或者资源，会分分钟刷出一个<strong>404</strong>来。</p></li></ul><p>希望本文所述对大家有所帮助。</p>`,34),p=[e];function t(r,c,i,d,h,y){return a(),n("div",null,p)}const F=s(l,[["render",t]]);export{D as __pageData,F as default};
