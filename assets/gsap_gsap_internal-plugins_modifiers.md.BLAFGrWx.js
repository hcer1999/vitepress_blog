import{l as t,c as l,a5 as o,v as e,i as a,a as i}from"./chunks/framework.DJyBczLA.js";const m=JSON.parse('{"title":"GSAP中文文档 - 修饰符插件（Modifiers）","description":"","frontmatter":{},"headers":[],"relativePath":"gsap/gsap/internal-plugins/modifiers.md","filePath":"gsap/gsap/internal-plugins/modifiers.md","lastUpdated":1733646466000}'),d={name:"gsap/gsap/internal-plugins/modifiers.md"};function c(s,r,n,p,u,h){return i(),l("div",null,r[0]||(r[0]=[o('<h1 id="gsap中文文档-修饰符插件-modifiers" tabindex="-1">GSAP中文文档 - 修饰符插件（Modifiers） <a class="header-anchor" href="#gsap中文文档-修饰符插件-modifiers" aria-label="Permalink to &quot;GSAP中文文档 - 修饰符插件（Modifiers）&quot;">​</a></h1><h2 id="修饰符插件-modifiers" tabindex="-1">修饰符插件（Modifiers） <a class="header-anchor" href="#修饰符插件-modifiers" aria-label="Permalink to &quot;修饰符插件（Modifiers）&quot;">​</a></h2><div class="info custom-block"><p class="custom-block-title">什么是内部插件？</p><p>ModifiersPlugin是一个内部插件，它<strong>自动包含在GSAP的核心中</strong>，<strong>不需要使用gsap.registerPlugin()来加载</strong>。</p><p>你可以将内部插件视为GSAP的一部分。</p></div><h2 id="描述" tabindex="-1">描述 <a class="header-anchor" href="#描述" aria-label="Permalink to &quot;描述&quot;">​</a></h2><p>你可以为几乎所有属性定义一个“修饰符”函数。这个修饰符拦截GSAP在每次更新（“tick”）时通常会应用的值，将其作为第一个参数传递给你的函数，并允许你运行自定义逻辑，返回一个新值，GSAP随后将应用这个值。这对于像吸附、限制、包装或其他动态效果的任务非常完美。</p><h2 id="value-target" tabindex="-1">value, target <a class="header-anchor" href="#value-target" aria-label="Permalink to &quot;value, target&quot;">​</a></h2><p>修饰符函数传递两个参数：</p><ol><li><p><code>value</code> (<em>number</em> | <em>string</em>) - 来自常规补间的即将被应用的值。这通常是数字，但可能是基于属性需求的字符串。例如，如果你正在动画化<code>x</code>属性，它将是一个数字，但如果动画化<code>left</code>属性，它可能是<code>&quot;212px&quot;</code>，或者对于<code>boxShadow</code>属性，它可能是<code>&quot;10px 5px 10px rgb(255,0,0)&quot;</code>。</p></li><li><p><code>target</code> (<em>object</em>) - 目标本身。</p></li></ol><p>例如，根据另一个对象的<code>y</code>改变一个对象的<code>x</code>，或根据移动方向改变<code>rotation</code>。以下是一些示例，可以帮助你熟悉语法。</p><h2 id="吸附旋转" tabindex="-1">吸附旋转 <a class="header-anchor" href="#吸附旋转" aria-label="Permalink to &quot;吸附旋转&quot;">​</a></h2><p>下面的补间动画使旋转360度，但修饰符函数强制值跳至最近的45度增量。注意修饰符函数如何获取被修改属性的值，在这种情况下是一个<code>rotation</code>数字。</p>',11),e("iframe",{src:"https://codepen.io/GreenSock/pen/BzJxBB",width:"100%",height:"400",scrolling:"no",frameborder:"no",allowtransparency:"true",allowfullscreen:"true"},null,-1),e("h2",{id:"使用模数限制",tabindex:"-1"},[a("使用模数限制 "),e("a",{class:"header-anchor",href:"#使用模数限制","aria-label":'Permalink to "使用模数限制"'},"​")],-1),e("p",null,[a("下面的补间动画使"),e("code",null,"x"),a("动画到500，但修饰符函数强制值包装，使其始终在0和100之间。")],-1),e("iframe",{src:"https://codepen.io/GreenSock/pen/MeQmaG",width:"100%",height:"400",scrolling:"no",frameborder:"no",allowtransparency:"true",allowfullscreen:"true"},null,-1),e("p",null,[a("使用GSAP的"),e("a",{href:"https://gsap.com/docs/v3/GSAP/UtilityMethods/wrap()",target:"_blank",rel:"noreferrer"},"wrap工具函数"),a("，实现相同的效果：")],-1),e("iframe",{src:"https://codepen.io/GreenSock/pen/WNeWZWb/5364a46c2767c6258132f7805ea0035e",width:"100%",height:"400",scrolling:"no",frameborder:"no",allowtransparency:"true",allowfullscreen:"true"},null,-1),o('<h2 id="走马灯包装" tabindex="-1">走马灯包装 <a class="header-anchor" href="#走马灯包装" aria-label="Permalink to &quot;走马灯包装&quot;">​</a></h2><p>你是否曾经构建过走马灯并为使其无缝循环而苦恼？也许复制了每个资产或编写了一些代码，当它到达末端时将每个项目移回开始。使用ModifiersPlugin，你可以用一个<code>.to()</code>和一个<code>stagger</code>得到一个无缝重复的走马灯！下面的示例将每个盒子补间到相对<code>x</code>位置<code>&quot;+=500&quot;</code>。点击“显示溢出”按钮，看看每个盒子在超过500时如何被重置为<code>x: 0</code>。</p>',2),e("iframe",{src:"https://codepen.io/GreenSock/pen/QEdpLe",width:"100%",height:"400",scrolling:"no",frameborder:"no",allowtransparency:"true",allowfullscreen:"true"},null,-1),o('<h2 id="高级演示" tabindex="-1">高级演示 <a class="header-anchor" href="#高级演示" aria-label="Permalink to &quot;高级演示&quot;">​</a></h2><p>我们只是触及了ModifiersPlugin能做什么的表面。我们的版主<a href="https://gsap.com/community/profile/21420-osublake/" target="_blank" rel="noreferrer">Blake Bowen</a>一直在测试这个插件，并有一个<a href="https://codepen.io/collection/AWxOyk/" target="_blank" rel="noreferrer">令人印象深刻的演示集合</a>，肯定会激发你的灵感。</p><h2 id="注意事项" tabindex="-1">注意事项： <a class="header-anchor" href="#注意事项" aria-label="Permalink to &quot;注意事项：&quot;">​</a></h2><ul><li><p>要修改CSS变换的<code>scale</code>，请使用<code>scaleX</code>和<code>scaleY</code>（因为它是这些的快捷方式）。并使用<code>rotation</code>，而不是<code>rotationZ</code>。</p></li><li><p>RoundPropsPlugin和SnapPlugin在内部与ModifiersPlugin使用相同的机制（为了最大化效率，最小化内存，并保持kb下降）。将<code>roundProps</code>补间视为仅创建一个修饰符的快捷方式，该修饰符应用<code>Math.round()</code>，因此你不能在同一个属性上同时进行<code>roundProps</code>和修饰符。不过，通过在修饰符函数内执行<code>Math.round()</code>，很容易获得该功能。</p></li></ul><h2 id="常见问题解答" tabindex="-1">常见问题解答： <a class="header-anchor" href="#常见问题解答" aria-label="Permalink to &quot;常见问题解答：&quot;">​</a></h2><details class="details custom-block"><summary>我如何将这个插件包含在我的项目中？</summary><p>只需加载GSAP的核心 - ModifiersPlugin自动包含！</p></details><details class="details custom-block"><summary>我需要注册ModifiersPlugin吗？</summary><p>不需要。ModifiersPlugin和其他核心插件内置于核心中，不需要注册。</p></details>',7)]))}const g=t(d,[["render",c]]);export{m as __pageData,g as default};
