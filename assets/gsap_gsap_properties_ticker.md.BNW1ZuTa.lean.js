import{l as a,a as i,c as e,a5 as n}from"./chunks/framework.DAV8GD4U.js";const o=JSON.parse('{"title":"GSAP中文文档 - gsap.ticker()","description":"","frontmatter":{},"headers":[],"relativePath":"gsap/gsap/properties/ticker.md","filePath":"gsap/gsap/properties/ticker.md","lastUpdated":1731921447000}'),t={name:"gsap/gsap/properties/ticker.md"};function p(l,s,r,h,d,c){return i(),e("div",null,s[0]||(s[0]=[n(`<h1 id="gsap中文文档-gsap-ticker" tabindex="-1">GSAP中文文档 - gsap.ticker() <a class="header-anchor" href="#gsap中文文档-gsap-ticker" aria-label="Permalink to &quot;GSAP中文文档 - gsap.ticker()&quot;">​</a></h1><h2 id="gsap-ticker" tabindex="-1">gsap.ticker() <a class="header-anchor" href="#gsap-ticker" aria-label="Permalink to &quot;gsap.ticker()&quot;">​</a></h2><p><code>gsap.ticker</code> 就像 GSAP 引擎的心跳一样 - 它在每个 <code>requestAnimationFrame</code> 事件上更新 <code>globalTimeline</code>，因此它与浏览器的渲染周期完美同步。您可以添加自己的监听器来在每次更新后运行自定义逻辑（对游戏开发者来说非常棒）。您可以添加任意数量的监听器。</p><h3 id="基本示例" tabindex="-1">基本示例 <a class="header-anchor" href="#基本示例" aria-label="Permalink to &quot;基本示例&quot;">​</a></h3><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 添加监听器</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">gsap.ticker.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(myFunction)</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> myFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">() {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 在核心引擎更新后的每个 tick 上执行</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 稍后移除监听器...</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">gsap.ticker.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">remove</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(myFunction)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="回调参数" tabindex="-1">回调参数 <a class="header-anchor" href="#回调参数" aria-label="Permalink to &quot;回调参数&quot;">​</a></h3><p>每个监听器函数都会接收以下参数：</p><ol><li><strong>time</strong>: <em>Number</em> - 自 ticker 开始以来的总时间（以秒为单位）。ticker 的开始时间可能会因 <code>lagSmoothing</code> 被推后。</li><li><strong>deltaTime</strong>: <em>Number</em> - 自上一个 tick 以来经过的毫秒数。注意：您可以使用 <code>gsap.ticker.deltaRatio()</code> 来获取基于特定目标 FPS 的比率。</li><li><strong>frame</strong>: <em>Number</em> - 每个 tick 上递增的帧（tick）编号。</li></ol><p>您的监听器函数可以像这样设置，以利用传递给它的参数：</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> myFunction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">time</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">deltaTime</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">frame</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  // 利用 time、deltaTime 和 frame</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="add-高级选项" tabindex="-1">.add() 高级选项 <a class="header-anchor" href="#add-高级选项" aria-label="Permalink to &quot;.add() 高级选项&quot;">​</a></h3><p>在 <code>gsap.ticker.add()</code> 中，您可以使用两个可选参数：</p><ul><li><strong>once</strong>: <em>Boolean</em> - 回调将只触发一次，然后自动被移除。</li><li><strong>prioritize</strong>: <em>Boolean</em> - 回调将被添加到队列的顶部而不是底部，这意味着它会在当前队列中的任何监听器之前触发。如果您希望您的回调在 GSAP 的全局时间轴之前触发，这是非常完美的。</li></ul><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 在下一个 requestAnimationFrame 中调用 myCallback 一次，在全局时间轴更新之前。</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">gsap.ticker.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(myCallback, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p><em>这些高级选项是在 GSAP 3.10.0 中添加的</em></p><h3 id="当标签页隐藏时的节流" tabindex="-1">当标签页隐藏时的节流 <a class="header-anchor" href="#当标签页隐藏时的节流" aria-label="Permalink to &quot;当标签页隐藏时的节流&quot;">​</a></h3><p>当用户在浏览器中切换到不同的标签页时，ticker 的更新会显著减少，以节省电池电量和减少 CPU 负载（这是因为浏览器本身降低了 <code>requestAnimationFrame</code> 事件的调度）。通常 <code>requestAnimationFrame</code> 事件每秒发生大约 60 次，但这取决于浏览器，也取决于系统性能。一些现代设备以 120Hz（每秒 120 次）更新。如果不支持 <code>requestAnimationFrame</code>，则 ticker 自动回退到使用常规的 <code>setTimeout()</code> 循环。</p><h3 id="ticker-属性" tabindex="-1">Ticker 属性 <a class="header-anchor" href="#ticker-属性" aria-label="Permalink to &quot;Ticker 属性&quot;">​</a></h3><ul><li><strong>time</strong>: <em>Number</em> - 自 ticker 开始以来的总时间（以秒为单位）。ticker 的开始时间可能会因 <code>lagSmoothing</code> 被推后。</li><li><strong>frame</strong>: <em>Number</em> - 每个 tick 上递增的帧（tick）编号。</li></ul><h3 id="gsap-ticker-fps" tabindex="-1">gsap.ticker.fps() <a class="header-anchor" href="#gsap-ticker-fps" aria-label="Permalink to &quot;gsap.ticker.fps()&quot;">​</a></h3><p>要将 ticker 限制在特定的帧率，您可以像这样使用 <code>fps()</code> 方法：</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 将帧率限制为每秒 30 帧</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">gsap.ticker.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">fps</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">30</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>由于不可能让浏览器加速原生的 <code>requestAnimationFrame</code> 事件（通常是每秒 60 帧），您不能像 <code>gsap.ticker.fps(100)</code> 那样做（嗯，您可以这样做，但它仍然以每秒大约 60 帧运行）。不过，您可以做 <code>gsap.ticker.fps(30)</code>，以便在必要时跳过节拍，以尽可能接近您设置的帧率（低于原生频率）。</p><h3 id="gsap-ticker-deltaratio-3-5-0-版本中添加" tabindex="-1">gsap.ticker.deltaRatio()（3.5.0 版本中添加） <a class="header-anchor" href="#gsap-ticker-deltaratio-3-5-0-版本中添加" aria-label="Permalink to &quot;gsap.ticker.deltaRatio()（3.5.0 版本中添加）&quot;">​</a></h3><p><code>gsap.ticker.deltaRatio()</code> 方法返回自上一 tick 以来经过的时间作为基于特定目标 FPS 的比率。例如，如果您做 <code>gsap.ticker.deltaRatio(60)</code>，但实际上自上一 tick 以来经过的时间更像是以每秒 30 帧运行（也许事情变得拥堵了），它将返回 <code>2</code>，这样您就可以轻松设置动态调整帧率变化的循环，如下所示：</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">gsap.ticker.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">add</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> () {</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  obj.x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">+=</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> 3</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> *</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> gsap.ticker.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">deltaRatio</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">60</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 即使帧率波动，变化率也将始终保持一致</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">})</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>默认的 <code>fps</code> 参数是 60，所以除非您使用不同于 60fps 的其他值，否则您甚至不需要传递一个。例如，如果您希望基于每秒 30 帧运行的比率，您将做 <code>gsap.ticker.deltaRatio(30)</code>。</p><p>这里有一个 Blake Bowen 的演示。</p><h3 id="gsap-ticker-lagsmoothing" tabindex="-1">gsap.ticker.lagSmoothing() <a class="header-anchor" href="#gsap-ticker-lagsmoothing" aria-label="Permalink to &quot;gsap.ticker.lagSmoothing()&quot;">​</a></h3><p><code>gsap.ticker.lagSmoothing()</code> 方法作为 GSAP 的延迟平滑的 getter 和 setter。</p><h4 id="当-cpu-拥堵并且呈现之间存在延迟时会发生什么" tabindex="-1">当 CPU 拥堵并且呈现之间存在延迟时会发生什么？ <a class="header-anchor" href="#当-cpu-拥堵并且呈现之间存在延迟时会发生什么" aria-label="Permalink to &quot;当 CPU 拥堵并且呈现之间存在延迟时会发生什么？&quot;">​</a></h4><p>例如，假设有一个应该立即开始的 2 秒补间动画，但 CPU 忙了整整一秒才能首次渲染该补间动画。大多数其他动画引擎（包括一些浏览器中的 CSS 动画）会将开始时间向前推以补偿，但这种方法有一个<strong>主要</strong>缺点：它牺牲了同步性，并且可能会破坏延迟，以至于当您尝试整齐地交错动画时，它们会成群/成组地出现。那不好。</p><p>GSAP 一直使用严格的时间模型，优先考虑完美的同步，这意味着在上面的例子中，补间动画将在最初的 1 秒延迟之后呈现为完成了一半。基本上，每个动画引擎都必须以某种方式支付延迟税 - 要么保持严格的时间和同步，要么四处滑动开始时间并失去同步。</p><p><code>gsap.ticker.lagSmoothing()</code> 为您提供了两者的最佳选择，因为当 CPU 拥堵时，它在下一个 tick 上调整核心计时机制，这会影响<strong>所有</strong>动画，因此所有内容都保持<strong>完美同步</strong>。您可以设置阈值（以毫秒为单位），以便每当延迟<strong>大于</strong>该阈值时，引擎将调整内部时钟，使其表现得好像 <code>adjustedLag</code> 经过了。即使您在 <code>gsap</code> 上调用静态方法，这种调整也会影响 GSAP 中的所有内容（补间动画、<code>timeline</code> 和 <code>delayedCall</code>，因为它们都是由 GSAP 核心的单个计时机制驱动的）。</p><p>例如，如果 <code>threshold</code> 是 <code>500</code>，<code>adjustedLag</code> 是 <code>33</code>（这些是默认值），只有在两个 tick 之间超过 500ms 时，才会进行调整，在这种情况下，它将表现得好像只有 33ms 经过了。因此，如果 CPU 拥堵了整整 2 秒（天啊！），您的动画将在下一个渲染中移动 33ms 的时间，而不是跳跃整整 2 秒。<strong>注意：</strong> 这不影响设备的性能或真实帧率 - 这只影响 GSAP 在浏览器丢帧时的反应。</p><p>此功能<strong>默认已激活</strong>，使用 <code>threshold</code> 为 500ms 和 <code>adjustedLag</code> 为 33ms，但如果您想更改设置，可以这样做：</p><div class="language-javascript vp-adaptive-theme line-numbers-mode"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// 当两个 tick 之间超过 1000ms 时进行补偿，然后让它表现得好像只有 16ms 经过了：</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">gsap.ticker.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">lagSmoothing</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1000</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">16</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">)</span></span></code></pre><div class="line-numbers-wrapper" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="为什么不将值设置得非常低-比如两个都设置为-10" tabindex="-1">为什么不将值设置得非常低，比如两个都设置为 10？ <a class="header-anchor" href="#为什么不将值设置得非常低-比如两个都设置为-10" aria-label="Permalink to &quot;为什么不将值设置得非常低，比如两个都设置为 10？&quot;">​</a></h3><p>因为这样做不会留出太多的喘息空间，而且很自然地会让您的运动看起来像是在更慢地运行（因为从技术上讲，如果时间几乎在每次渲染时都被推前，它们确实在变慢）。还要注意，如果您有任何 <code>delayedCalls</code>，这些也会受到影响。这是一件好事 - 它确保您可以依赖它们与引擎的其余部分完全同步，但如果浏览器承受着巨大压力，并且每秒只渲染几个帧，那么看起来就好像时间真的在减慢，一个 2 秒的补间动画（或 <code>delayedCall</code>）实际上可能需要 8 秒才能完成。</p><p>在大多数现实世界的场景中，500 和 33 的默认值是理想的，因为它们可以防止浏览器/CPU 的重大中断，同时允许帧率的小幅度变化而不会不必要地减慢速度。</p><p>如果您想禁用延迟平滑，您可以简单地将其设置为 0，如 <code>gsap.ticker.lagSmoothing(0)</code>，这与将阈值设置为一个非常大的值以使其永远不会启动是一样的。</p>`,41)]))}const g=a(t,[["render",p]]);export{o as __pageData,g as default};
