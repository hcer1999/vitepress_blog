---
title: Next.js 中文文档 - 缓存
description: Next.js缓存机制的深入解析
---

# Next.js 中文文档 - Next.js中的缓存

Next.js包含各种缓存机制，以帮助您构建更快的应用程序。本页将深入介绍Next.js中的各种缓存机制，包括它们的工作原理、持续时间以及如何配置它们。

## 缓存概述

缓存是一种存储数据以便能够更快速地提供服务的机制。在Web应用程序中，缓存可以发生在不同的级别，包括：

- **客户端缓存**：浏览器储存资源的副本
- **服务器缓存**：服务器储存资源的副本
- **CDN缓存**：内容分发网络储存资源的副本

Next.js提供了多种内置的缓存机制，使您能够在不同级别上缓存数据和UI组件，包括：

| 机制                          | 描述                                         | 位置           | 持续时间                                |
| ----------------------------- | -------------------------------------------- | -------------- | --------------------------------------- |
| [请求记忆](#请求记忆)         | 在React组件树中缓存单个HTTP请求              | 服务器         | 每次构建/部署或通过路由处理程序重新验证 |
| [数据缓存](#数据缓存)         | 在跨用户和请求的应用程序中缓存数据           | 服务器         | 持久（可配置）                          |
| [完整路由缓存](#完整路由缓存) | 缓存React Server Component有效载荷           | 服务器和客户端 | 持久（可配置）                          |
| [路由器缓存](#路由器缓存)     | 缓存浏览器中的React Server Component有效载荷 | 客户端         | 用户会话或根据时间/导航事件重置         |

## 请求记忆

请求记忆（Request Memoization）是一种React功能，允许您缓存函数调用的结果，包括数据获取。例如，如果您在同一组件树或渲染过程中多次调用相同的`fetch`请求，只有第一个请求会被执行，而其结果将被缓存和重用。

```tsx
// 该函数被调用多次，但只执行一次fetch
async function getItem() {
  const res = await fetch('https://.../item/1')
  return res.json()
}

// 第一次调用 - fetch请求被执行
const item = await getItem() // { id: 1, name: 'Test' }

// 第二次调用 - 返回已缓存的结果而不执行fetch
const item2 = await getItem() // { id: 1, name: 'Test' }
```

请求记忆可以帮助：

- **提高性能**：通过避免重复的网络请求
- **减少资源使用**：通过减少数据库查询或外部API调用
- **保持数据一致性**：确保组件树内的所有组件使用相同的数据

请求记忆仅在单个渲染过程中起作用，一旦页面完成渲染，缓存就会重置。缓存发生在React Server Component渲染过程中，因此记忆化的数据不会在用户之间共享。

## 数据缓存

Next.js有一个内置的数据缓存系统，允许您存储数据跨请求和用户使用。这种持久缓存是可配置的，可以根据需要设置不同的缓存行为：

```tsx
// 默认情况下，此fetch请求被无限期缓存
fetch('https://...')

// 此请求使用缓存，直到被手动失效
fetch('https://...', { cache: 'force-cache' })

// 此请求将在每个新的请求时重新获取
fetch('https://...', { cache: 'no-store' })

// 此请求将在60秒后重新验证
fetch('https://...', { next: { revalidate: 60 } })
```

您还可以使用`revalidatePath`和`revalidateTag`手动重新验证数据，使缓存在更新时立即失效：

```tsx
// 使用path无效缓存
revalidatePath('/')

// 使用tag无效缓存
revalidateTag('collection')
```

数据缓存适用于：

- **持久化数据**：在用户会话和请求之间维护数据
- **动态数据**：控制数据何时需要重新获取
- **多层应用**：在多个服务器或边缘网络节点之间共享缓存

## 完整路由缓存

Next.js会在构建时或请求时在服务器上自动缓存渲染的React Server Component，从而提高后续请求的性能。当用户访问已缓存路由时，服务器不需要重新渲染页面，而是立即返回缓存结果。

这种缓存行为可以通过多种方式配置：

```tsx
// 禁用特定路由的缓存
export const dynamic = 'force-dynamic'

// 在页面级别设置重新验证时间
export const revalidate = 60 // 每60秒重新验证
```

路由缓存与数据缓存紧密相关。当数据缓存重新验证时，使用该数据的路由也会自动重新渲染，保持UI与最新数据同步。

## 路由器缓存

Next.js在客户端维护一个路由器缓存，用于存储用户在应用程序中导航时访问过的React Server Component有效载荷。这使得用户可以在路由之间快速前进和后退，而无需重新获取相同的数据。

路由器缓存适用于单个用户会话，并在以下情况下重置：

- 浏览器选项卡刷新
- 浏览器离开/重新进入选项卡
- 用户返回浏览器历史（前进/后退导航）

您可以在应用程序中控制路由器缓存的行为，例如：

```tsx
// 手动清除路由器缓存并重新获取最新数据
router.refresh()
```

## 缓存优化策略

要充分利用Next.js的缓存机制，建议以下最佳实践：

1. **使用静态渲染作为默认策略**：尽可能使用静态渲染，将动态内容限制在需要的地方
2. **精细控制缓存失效**：使用`revalidatePath`或`revalidateTag`精确失效需要更新的部分
3. **合理设置重新验证时间**：根据数据更新频率设置适当的重新验证间隔
4. **使用流式传输**：对于较慢的数据获取操作，考虑使用React Suspense和流式传输来提高感知性能

## 故障排除

如果您遇到缓存相关问题，可以尝试以下步骤：

1. **确认缓存配置**：检查是否正确设置了`cache`、`revalidate`或其他缓存选项
2. **检查部署环境**：开发环境和生产环境的缓存行为可能不同
3. **使用开发工具**：使用浏览器开发工具检查网络请求和缓存状态
4. **查看路由配置**：确保路由级别的配置（如`dynamic`设置）与您的预期一致

## 下一步

了解Next.js的缓存机制后，建议您深入学习以下相关主题：

- [数据获取和缓存](/nextjs/app-router/building-your-application/data-fetching/data-fetching-and-caching) - 了解更多关于数据获取和缓存的详细信息
- [静态和动态渲染](/nextjs/app-router/building-your-application/rendering/static-and-dynamic-rendering) - 学习渲染模式如何与缓存交互
- [重新验证和按需重新验证](/nextjs/app-router/building-your-application/data-fetching/revalidating) - 了解如何更新已缓存的数据
